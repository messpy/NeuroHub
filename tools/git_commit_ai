#!/usr/bin/env bash
# git_commit_ai_individual_interactive.sh
# ------------------------------------------------------------
# 個別ステージ + 対話確認版:
#  - 作業ツリーから対象ファイル一覧（変更/新規/削除）
#  - 1ファイルずつステージ → AI生成（Gemini→Ollama）
#  - 生成失敗時はユーザー入力にフォールバック
#  - 各ファイルごとに「これでいいですか？」確認（編集/再生成/手入力/スキップ/中止）
#  - センシティブ内容を追加行で検出した場合はスキップ
#  - 進捗ログ + 区切り表示（####################### ファイル名 #######################）
# ------------------------------------------------------------

set -euo pipefail
log() { printf '%s\n' "$*" >&2; }

log ">> git_commit_ai_individual_interactive.sh start (pwd=$(pwd))"

# ===== 基本設定 =====
LANG_CODE="ja"
MAX_LEN=40
MAX_RETRY=2
DIFF_HEAD_LINES=500

# ===== Gitチェック =====
if ! GIT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null)"; then
  log "Gitリポジトリ内で実行してください。"
  exit 1
fi
log ">> GIT_ROOT=$GIT_ROOT"

# ===== 設定探索 =====
find_config_dir() {
  if [[ -n "${NEUROHUB_CONFIG:-}" && -d "${NEUROHUB_CONFIG}" ]]; then echo "$NEUROHUB_CONFIG"; return; fi
  if [[ -n "${NEUROHUB_ROOT:-}" && -d "${NEUROHUB_ROOT}/config" ]] ; then echo "$NEUROHUB_ROOT/config"; return; fi
  local base="$PWD"
  while :; do
    [[ -f "$base/config/config.yaml" ]] && echo "$base/config" && return
    [[ "$base" == "/" ]] && break
    base="$(dirname "$base")"
  done
  [[ -f "$HOME/NeuroHub/config/config.yaml" ]] && echo "$HOME/NeuroHub/config" && return
  [[ -f "$GIT_ROOT/config/config.yaml" ]] && echo "$GIT_ROOT/config" && return
}
CONF_DIR="$(find_config_dir || true)"
CONF_YAML="${CONF_DIR:-}/config.yaml"
CONF_ENV="${CONF_DIR:-}/.env"
log ">> CONF_DIR=${CONF_DIR:-none}"

# 既定
OLLAMA_HOST_VAL="http://127.0.0.1:11434"
OLLAMA_MODEL=""
GEM_API_URL="https://generativelanguage.googleapis.com/v1"
GEM_MODEL="gemini-2.5-flash"
GEM_API_KEY="${GEMINI_API_KEY:-}"

# .env
if [[ -f "$CONF_ENV" ]]; then
  if grep -q '^GEMINI_API_KEY=' "$CONF_ENV"; then
    GEM_API_KEY="$(grep '^GEMINI_API_KEY=' "$CONF_ENV" | tail -n1 | cut -d= -f2-)"
  fi
  if grep -q '^OLLAMA_HOST=' "$CONF_ENV"; then
    OLLAMA_HOST_VAL="$(grep '^OLLAMA_HOST=' "$CONF_ENV" | tail -n1 | cut -d= -f2-)"
  fi
fi

# config.yaml（任意）
if [[ -f "$CONF_YAML" ]] && command -v yq >/dev/null 2>&1; then
  OLLAMA_HOST_VAL="$(yq -r '.llm.ollama.host // "http://127.0.0.1:11434"' "$CONF_YAML")"
  OLLAMA_MODEL="$(yq -r '.llm.ollama.selected_model // ""' "$CONF_YAML")"
  GEM_API_URL="$(yq -r '.llm.gemini.api_url // "https://generativelanguage.googleapis.com/v1"' "$CONF_YAML")"
  GEM_MODEL="$(yq -r '.llm.gemini.model // "gemini-2.5-flash"' "$CONF_YAML")"
fi
[[ -z "$OLLAMA_MODEL" ]] && OLLAMA_MODEL="qwen2.5:1.5b-instruct"
log ">> OLLAMA_HOST=$OLLAMA_HOST_VAL  OLLAMA_MODEL=$OLLAMA_MODEL  GEM_MODEL=$GEM_MODEL"

# ===== センシティブ内容検出（内容ベースのみ） =====
SECRET_REGEXES=(
  '-----BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----'
  'AKIA[0-9A-Z]{16}'
  'ghp_[0-9A-Za-z]{36,}'
  'github_pat_[0-9A-Za-z_]{20,}'
)

has_secret_in_cached_diff() { # $1=file（ステージ済みの追加行をスキャン）
  local f="$1"
  local added
  added="$(git diff --cached -- "$f" | sed -n 's/^+//p' || true)"
  [[ -z "$added" ]] && return 1

  local key_begin='-----BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----'
  local key_end='-----END (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----'
  if grep -Eq -e "$key_begin" <<<"$added" && grep -Eq -e "$key_end" <<<"$added"; then
    if ! grep -Eq "[\"'#]" <<<"$added"; then
      return 0
    fi
  fi
  local rx
  for rx in "${SECRET_REGEXES[@]}"; do
    [[ "$rx" == "$key_begin" ]] && continue
    if grep -Eq -e "$rx" <<<"$added"; then
      return 0
    fi
  done
  return 1
}

# ===== AI プロンプト =====
make_base_prompt() {
cat <<EOF
次の差分から、NeuroHubスタイルのコミットメッセージを生成してください。

==== Format ====
:prefix: #Issue 内容
例:
:add: #123 新規API追加
:fix: #45 ログ出力の不具合修正

==== ルール ====
・絵文字は使わない
・1行目は :prefix: #issue(optional) を必ず先頭に
・変更内容は日本語で簡潔に（${MAX_LEN}文字以内）
・句読点なし、敬語不要
EOF
}

generate_message_once() {
  local prompt_full="$1" msg=""
  if [[ -n "${GEM_API_KEY:-}" ]] && command -v jq >/dev/null 2>&1; then
    log "gemini生成中... (${GEM_MODEL})"
    local url req resp
    url="${GEM_API_URL%/}/models/${GEM_MODEL}:generateContent?key=${GEM_API_KEY}"
    req="$(jq -nc --arg t "$prompt_full" '{contents:[{parts:[{text:$t}]}]}')"
    resp="$(curl -sS -H "Content-Type: application/json" -d "$req" "$url" || true)"
    if jq -e '.error' >/dev/null 2>&1 <<<"$resp"; then
      log "Gemini失敗"
    else
      msg="$(jq -r '.candidates[0].content.parts[0].text // ""' <<<"$resp" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g' | head -n1)"
    fi
  fi
  if [[ -z "$msg" ]]; then
    log "Ollama生成中... (${OLLAMA_MODEL})"
    export OLLAMA_HOST="$OLLAMA_HOST_VAL"
    local raw; raw="$(printf "%s" "$prompt_full" | ollama run "$OLLAMA_MODEL" 2>/dev/null || true)"
    msg="$(printf "%s" "$raw" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g' | head -n1)"
  fi
  [[ -n "$msg" && ${#msg} -gt $MAX_LEN ]] && msg="${msg:0:$MAX_LEN}"
  printf '%s\n' "$msg"
}

# ===== 重複メッセージ回避 =====
declare -A USED_MSGS=()
is_dup_msg() { [[ -n "${USED_MSGS[$1]:-}" ]]; }
mark_msg() { USED_MSGS["$1"]=1; }

# ===== 対象ファイル一覧（個別ステージ方針） =====
mapfile -t FILES < <( { git ls-files -m; git ls-files -o --exclude-standard; git ls-files -d; } | sort -u )

if (( ${#FILES[@]} == 0 )); then
  log "コミット対象なし（作業ツリーに変更がありません）"
  exit 0
fi
log ">> target files (working tree): ${#FILES[@]}"

sep_line() {
  printf '\n####################### %s #######################\n' "$1"
}

# ===== 1ファイルずつ処理 =====
for f in "${FILES[@]}"; do
  sep_line "$f"
  log ">> processing: $f"

  # ステージ操作（個別） + ログ/プリント
  if [[ ! -e "$f" ]]; then
    git rm -- "$f" >/dev/null 2>&1 || true
    log "   -> staged (rm) $f"
  else
    git add -- "$f" >/dev/null 2>&1 || true
    log "   -> staged (add) $f"
  fi
  printf "#######################"; printf "%s" "$f"; printf "#######################\n"

  # ステージ済み差分を取得（その1件だけ）
  diff_text="$(git diff --cached -- "$f")"
  if [[ -z "$diff_text" ]]; then
    log "   -> 変更なし（スキップ）"
    continue
  fi

  # センシティブ内容チェック（内容ベースのみ）
  if has_secret_in_cached_diff "$f"; then
    log "⚠  センシティブパターン検出、スキップ: $f"
    git restore --staged -- "$f" >/dev/null 2>&1 || true
    continue
  fi

  # プロンプト組み立て
  prompt="$(make_base_prompt)
==== 対象ファイル ====
$f

==== 差分（抜粋） ====
$(printf "%s" "$diff_text" | head -n "$DIFF_HEAD_LINES")
"

  # 生成（重複回避付き）
  rejects=()
  message="$(generate_message_once "$prompt")"
  tries=0
  while { [[ -z "$message" ]] || is_dup_msg "$message"; } && (( tries < MAX_RETRY )); do
    [[ -z "$message" ]] && log "   -> 生成空、再試行..." || log "   -> 重複検出、再生成..."
    rejects+=("$message")
    prompt+=$'\n'"※他ファイルと同一の1行目は不可。対象: $f"
    message="$(generate_message_once "$prompt")"
    ((tries++))
  done

  # もしAIが空や不適切なら、ユーザー入力にフォールバック
  if [[ -z "$message" ]]; then
    echo
    echo "ファイル: $f"
    echo "AIで生成に失敗しました。手入力してください。"
    read -r -p "コミットメッセージ: " message
  fi

  # 対話確認ループ
  while :; do
    echo
    echo "ファイル: $f"
    echo "コミットメッセージ候補:"
    echo "--------------------------------"
    echo "$message"
    echo "--------------------------------"
    read -r -p "[Enter=確定 / e=編集 / r=再生成 / m=手入力 / s=スキップ / q=中止] " ans
    case "${ans:-}" in
      "" )
        # 確定
        git commit -m "$message" -- "$f" || true
        mark_msg "$message"
        log "✅ $f → $message"
        break
        ;;
      e|E )
        if [[ -n "${EDITOR:-}" ]]; then
          tmpfile="$(mktemp)"
          printf "%s" "$message" > "$tmpfile"
          "$EDITOR" "$tmpfile"
          message="$(cat "$tmpfile")"
          rm -f "$tmpfile"
        else
          read -r -p "新しいメッセージ: " newmsg
          [[ -n "$newmsg" ]] && message="$newmsg"
        fi
        ;;
      r|R )
        rejects+=("$message")
        prompt+=$'\n'"※前案は不採用。もっと具体的に/重複回避。対象: $f"
        newmsg="$(generate_message_once "$prompt")"
        if [[ -n "$newmsg" ]]; then message="$newmsg"; else log "   -> 再生成失敗、保持"; fi
        ;;
      m|M )
        read -r -p "手入力メッセージ: " newmsg
        [[ -n "$newmsg" ]] && message="$newmsg"
        ;;
      s|S )
        git restore --staged -- "$f" >/dev/null 2>&1 || true
        log "   -> スキップ: $f（アンステージ済み）"
        break
        ;;
      q|Q )
        log "   -> ユーザー中止"
        exit 1
        ;;
      * )
        echo "入力が無効です。"
        ;;
    esac
  done
done

log "完了"

